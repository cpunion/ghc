## TODO FIRST

* tcTyClGroup and stuff
  - setLclEnv generalized_env tyCl...Decl
  - type check (kind check and desugar) using generalized_env at once
  - checkValidTyCl done for each group

* kind substitution in types, substTyVarBndr
  look at CoreSubst, substIdBndr
  no_kind_change : verify that kind is closed

* UserKiVar (in Parser mkHsForAll or renamer)
  look at kind annotation to know if a UserTyvar is a kind variable
  (UserKiVar) or a type variable (UserTyVar)
  forall k f (a :: k). f a -> Int
  HsForAll Explicit [UserKiVar k, UserTyVar f, KindedTyVar a k] ...

* ds_type takes a flag
  - either it does defaulting: alpha -> star
  - or it zonks to a kind variable: alpha -> k7
  When we kind generalize, we gather the free kind variables and quantify over them.

* Get rid special cases for Any and (~), make them polymorphic and behave like any other TyCon.


## TODO NEXT

* Promotion of DataCon (and associated AlgTyCon)
  In DataCon:
    Add field dcPromoted :: Maybe TyCon
    A DataCon is promotable if:
      - dcVanilla == True
      - isPromotableType dataConUserType
      - all its siblings are promotable (Just tc)
  In AlgTyCon:
    Add field algTcPromoted :: Maybe Int
      where the Int is the number of kind arguments it takes
    A TyCon is promotable if:
      - it's kind is promotable  * -> * ... -> *
      - all its DataCon are promotable

* Renaming in TcHsType
  scDs -> tc
  tcHsKindedType -> dsHsKindedType
  Explain that:
  kc = kind check
  ds = desugar
  tc = kc + ds

* write a testsuite named kinds with everything I can think of
  - translate Faking it (Conor)
  - when translating, add a reference to the thing being translated

* write a user manual
  - haskell.org/haskellwiki/GHC/kinds
    describe informally how we can use them


## BUGS

* Error messages for things like:
  data T a = K (a K)

* Promoted primitive negative integers are not parsed.
  > f :: -1


## OPTIONAL

* Pattern match(es) are non-exhaustive (splitAt in Vector.hs)
  The problem is already there in master.

* No wildpat in types.  Neither is there a warning on unused variables.

* ''a' -> ITtyvar a'
  instead of ITsimplequote 'a'

* Getting rid of subkinding.

  kappa ::= eta | # | (#) | ? | ??
  eta ::= * | eta -> eta | T eta .. eta

  Gamma, alpha : ??, x : alpha |- e
  ----------------------------------
  Gamma |- \x -> e

  error : forall (a : ?). String -> a  (still weird)

  Gamma |- tau : kappa1 in * or #
  Gamma |- sigma : kappa2 in * or # or (#)
  ----------------------------------------
  Gamma |- tau -> sigma : *

  ? and ?? only appear at top level, and they always get set to star
  when unified with a meta kind variable

* data HsExpr id = ... | HsOpApp .. (HsOp id) .. | ...
  type HsOp name = (name, Fixity, HsWrapper)

* Make `+' be a TcClsName instead of VarName:
  data a + b = Left a | Right b

* Kind generalize instead of zonking to kind
  > data SList s as where
  >   SNil :: SList s Nil
  >   SCons :: s a -> SList s as -> SList s (Cons a as)
  would return SList :: forall (k :: BOX). (k -> *) -> List k -> *
  and not SList :: (* -> *) -> List * -> *


----------------------------------------------------------------------
--                             HELPERS                              --
----------------------------------------------------------------------

  1. How to check conflicts in the parser

% cd compiler/parser
% gcc -E -undef -traditional -P -Iincludes -x c Parser.y.pp | grep -v '^#pragma GCC' >! Parser.y && happy -agc --strict Parser.y -i

