## TODO FIRST

* write a testsuite named kinds with everything I can think of
  - translate Faking it (Conor)
  - when translating, add a reference to the thing being translated

* write a user manual
  - haskell.org/haskellwiki/GHC/kinds
    describe informally how we can use them


## TODO NEXT


## BUGS

* Do some sharing for promoted things, so that when I lookup K in a
  type, I verify only once that it is promotable, and I don't build
  several identical PromotedDataTyCon.
  Add field about promotion:
  - in DataCon: Maybe TyCon (the promoted TyCon)
  - in AlgTyCon: Maybe Int which means
    - T's kind is promotable (Just n)  *^n -> *
    - all its DataCon are promotable

* Error messages for things like:
  data T a = K (a K)

* Promoted primitive negative integers are not parsed.
  > f :: -1


## OPTIONAL

* Pattern match(es) are non-exhaustive (splitAt in Vector.hs)
  The problem is already there in master.

* No wildpat in types.  Neither is there a warning on unused variables.

* ''a' -> ITtyvar a'
  instead of ITsimplequote 'a'

* Getting rid of subkinding.

  kappa ::= eta | # | (#) | ? | ??
  eta ::= * | eta -> eta | T eta .. eta

  Gamma, alpha : ??, x : alpha |- e
  ----------------------------------
  Gamma |- \x -> e

  error : forall (a : ?). String -> a  (still weird)

  Gamma |- tau : kappa1 in * or #
  Gamma |- sigma : kappa2 in * or # or (#)
  ----------------------------------------
  Gamma |- tau -> sigma : *

  ? and ?? only appear at top level, and they always get set to star
  when unified with a meta kind variable

* data HsExpr id = ... | HsOpApp .. (HsOp id) .. | ...
  type HsOp name = (name, Fixity, HsWrapper)

* Make `+' be a TcClsName instead of VarName:
  data a + b = Left a | Right b

* Kind generalize instead of zonking to kind
  > data SList s as where
  >   SNil :: SList s Nil
  >   SCons :: s a -> SList s as -> SList s (Cons a as)
  would return SList :: forall (k :: BOX). (k -> *) -> List k -> *
  and not SList :: (* -> *) -> List * -> *


----------------------------------------------------------------------
--                             HELPERS                              --
----------------------------------------------------------------------

  1. How to check conflicts in the parser

% cd compiler/parser
% gcc -E -undef -traditional -P -Iincludes -x c Parser.y.pp | grep -v '^#pragma GCC' >! Parser.y && happy -agc --strict Parser.y -i

